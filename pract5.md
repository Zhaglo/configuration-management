## ЗАДАНИЕ 1.

---

#### Байт-код для разбора:
~~~scss
11  0 LOAD_FAST        0 (x)
    2 LOAD_CONST       1 (10)
    4 BINARY_MULTIPLY
    6 LOAD_CONST       2 (42)
    8 BINARY_ADD
    10 RETURN_VALUE
~~~

#### Разбор по шагам:

1. LOAD_FAST 0 (x)

* Команда загружает локальную переменную x на вершину стека.
* Эквивалент: Значение переменной x.
2. LOAD_CONST 1 (10)

* Команда загружает константу 10 на вершину стека.
* Эквивалент: Константа 10.
3. BINARY_MULTIPLY

* Команда снимает два верхних значения со стека (x и 10), умножает их и кладет результат обратно на стек.
* Эквивалент: x * 10.
4. LOAD_CONST 2 (42)

* Команда загружает константу 42 на вершину стека.
* Эквивалент: Константа 42.
5. BINARY_ADD

* Команда снимает два верхних значения со стека (результат умножения x * 10 и 42), складывает их и кладет результат обратно на стек.
* Эквивалент: (x * 10) + 42.
6. RETURN_VALUE

* Команда завершает выполнение функции, возвращая значение на вершине стека как результат.
* Эквивалент: Возвращение результата (x * 10) + 42.

### Итоговое Python-выражение
Байткод выполняет следующий эквивалентный Python-код:

~~~python
return (x * 10) + 42
~~~

## ЗАДАНИЕ 2.

---

### Байткод с описанием шагов
#### Инициализация:
~~~scss
  5           0 LOAD_CONST               1 (1)
              2 STORE_FAST               1 (r)
~~~
1. Команда LOAD_CONST 1 (1) загружает константу 1 на стек.
2. Команда STORE_FAST 1 (r) сохраняет значение 1 в локальную переменную r.

Результат: r = 1.
#### Проверка условия:
~~~scss
  6     >>    4 LOAD_FAST                0 (n)
              6 LOAD_CONST               1 (1)
              8 COMPARE_OP               4 (>)
             10 POP_JUMP_IF_FALSE       30
~~~
3. Команда LOAD_FAST 0 (n) загружает значение локальной переменной n на стек.
4. Команда LOAD_CONST 1 (1) загружает константу 1 на стек.
5. Команда COMPARE_OP 4 (>) сравнивает значения n и 1 (проверка: n > 1).
6. Команда POP_JUMP_IF_FALSE 30 передает управление на адрес 30, если условие ложно (n <= 1).
#### Основной цикл:
~~~scss
  7          12 LOAD_FAST                1 (r)
             14 LOAD_FAST                0 (n)
             16 INPLACE_MULTIPLY
             18 STORE_FAST               1 (r)

  8          20 LOAD_FAST                0 (n)
             22 LOAD_CONST               1 (1)
             24 INPLACE_SUBTRACT
             26 STORE_FAST               0 (n)

             28 JUMP_ABSOLUTE            4
~~~
7. Внутри цикла:

* LOAD_FAST 1 (r) загружает текущее значение r.
* LOAD_FAST 0 (n) загружает текущее значение n.
* INPLACE_MULTIPLY умножает r на n и обновляет значение r (операция r *= n).
* STORE_FAST 1 (r) сохраняет обновленное значение r.
8. Уменьшение n:

* LOAD_FAST 0 (n) загружает текущее значение n.
* LOAD_CONST 1 (1) загружает константу 1.
* INPLACE_SUBTRACT вычитает 1 из n и обновляет значение n (операция n -= 1).
* STORE_FAST 0 (n) сохраняет обновленное значение n.
9. Команда JUMP_ABSOLUTE 4 возвращает выполнение к началу цикла (адрес 4) для проверки условия.

#### Возврат результата:
~~~scss
  9     >>   30 LOAD_FAST                1 (r)
             32 RETURN_VALUE
~~~
10. LOAD_FAST 1 (r) загружает текущее значение r на стек.
11. RETURN_VALUE завершает функцию и возвращает значение r.
### Результат работы
Функция вычисляет факториал числа n с помощью цикла.

### Известная функция
Байткод соответствует реализации факториала с использованием итерации:

~~~python
def factorial(n):
    r = 1
    while n > 1:
        r *= n
        n -= 1
    return r
~~~