## ЗАДАНИЕ 1.

---

#### Байт-код для разбора:
~~~scss
11  0 LOAD_FAST        0 (x)
    2 LOAD_CONST       1 (10)
    4 BINARY_MULTIPLY
    6 LOAD_CONST       2 (42)
    8 BINARY_ADD
    10 RETURN_VALUE
~~~

#### Разбор по шагам:

1. LOAD_FAST 0 (x)

* Команда загружает локальную переменную x на вершину стека.
* Эквивалент: Значение переменной x.
2. LOAD_CONST 1 (10)

* Команда загружает константу 10 на вершину стека.
* Эквивалент: Константа 10.
3. BINARY_MULTIPLY

* Команда снимает два верхних значения со стека (x и 10), умножает их и кладет результат обратно на стек.
* Эквивалент: x * 10.
4. LOAD_CONST 2 (42)

* Команда загружает константу 42 на вершину стека.
* Эквивалент: Константа 42.
5. BINARY_ADD

* Команда снимает два верхних значения со стека (результат умножения x * 10 и 42), складывает их и кладет результат обратно на стек.
* Эквивалент: (x * 10) + 42.
6. RETURN_VALUE

* Команда завершает выполнение функции, возвращая значение на вершине стека как результат.
* Эквивалент: Возвращение результата (x * 10) + 42.

### Итоговое Python-выражение
Байткод выполняет следующий эквивалентный Python-код:

~~~python
return (x * 10) + 42
~~~

## ЗАДАНИЕ 2.

---

### Байткод с описанием шагов
#### Инициализация:
~~~scss
  5           0 LOAD_CONST               1 (1)
              2 STORE_FAST               1 (r)
~~~
1. Команда LOAD_CONST 1 (1) загружает константу 1 на стек.
2. Команда STORE_FAST 1 (r) сохраняет значение 1 в локальную переменную r.

Результат: r = 1.
#### Проверка условия:
~~~scss
  6     >>    4 LOAD_FAST                0 (n)
              6 LOAD_CONST               1 (1)
              8 COMPARE_OP               4 (>)
             10 POP_JUMP_IF_FALSE       30
~~~
3. Команда LOAD_FAST 0 (n) загружает значение локальной переменной n на стек.
4. Команда LOAD_CONST 1 (1) загружает константу 1 на стек.
5. Команда COMPARE_OP 4 (>) сравнивает значения n и 1 (проверка: n > 1).
6. Команда POP_JUMP_IF_FALSE 30 передает управление на адрес 30, если условие ложно (n <= 1).
#### Основной цикл:
~~~scss
  7          12 LOAD_FAST                1 (r)
             14 LOAD_FAST                0 (n)
             16 INPLACE_MULTIPLY
             18 STORE_FAST               1 (r)

  8          20 LOAD_FAST                0 (n)
             22 LOAD_CONST               1 (1)
             24 INPLACE_SUBTRACT
             26 STORE_FAST               0 (n)

             28 JUMP_ABSOLUTE            4
~~~
7. Внутри цикла:

* LOAD_FAST 1 (r) загружает текущее значение r.
* LOAD_FAST 0 (n) загружает текущее значение n.
* INPLACE_MULTIPLY умножает r на n и обновляет значение r (операция r *= n).
* STORE_FAST 1 (r) сохраняет обновленное значение r.
8. Уменьшение n:

* LOAD_FAST 0 (n) загружает текущее значение n.
* LOAD_CONST 1 (1) загружает константу 1.
* INPLACE_SUBTRACT вычитает 1 из n и обновляет значение n (операция n -= 1).
* STORE_FAST 0 (n) сохраняет обновленное значение n.
9. Команда JUMP_ABSOLUTE 4 возвращает выполнение к началу цикла (адрес 4) для проверки условия.

#### Возврат результата:
~~~scss
  9     >>   30 LOAD_FAST                1 (r)
             32 RETURN_VALUE
~~~
10. LOAD_FAST 1 (r) загружает текущее значение r на стек.
11. RETURN_VALUE завершает функцию и возвращает значение r.
### Результат работы
Функция вычисляет факториал числа n с помощью цикла.

### Известная функция
Байткод соответствует реализации факториала с использованием итерации:

~~~python
def factorial(n):
    r = 1
    while n > 1:
        r *= n
        n -= 1
    return r
~~~

## ЗАДАНИЕ 3.

---

### Функция задания №1
~~~
def foo(x):
    while x:
        x -= 1
    return x + 1
~~~
#### Реализация на Java
~~~java
public class Task1 {
    public static int foo(int x) {
        while (x > 0) {
            x -= 1;
        }
        return x + 1;
    }

    public static void main(String[] args) {
        System.out.println(foo(5));
    }
}
~~~
#### JVM байткод (команда javap -c Task1)
~~~plaintext
public static int foo(int);
  Code:
   0: iload_0            // Загрузить значение x в стек
   1: ifle        12     // Если x <= 0, перейти на 12 (конец цикла)
   4: iinc        0, -1  // Уменьшить значение x на 1 (x -= 1)
   7: goto        0      // Перейти к началу цикла
  10: iload_0            // Загрузить x в стек
  11: iconst_1           // Загрузить 1 в стек
  12: iadd               // Сложить x и 1
  13: ireturn            // Вернуть результат
~~~

### Функция факториала
#### Реализация на Java
~~~java
public class Task2 {
    public static int factorial(int n) {
        int r = 1;
        while (n > 1) {
            r *= n;
            n -= 1;
        }
        return r;
    }

    public static void main(String[] args) {
        System.out.println(factorial(5));
    }
}
~~~
#### JVM байткод (команда javap -c Task2)
~~~plaintext
public static int factorial(int);
  Code:
   0: iconst_1           // Загрузить 1 в стек
   1: istore_1           // Сохранить 1 в r
   2: iload_0            // Загрузить n в стек
   3: iconst_1           // Загрузить 1 в стек
   4: if_icmple   18     // Если n <= 1, перейти на 18 (конец цикла)
   7: iload_1            // Загрузить r
   8: iload_0            // Загрузить n
   9: imul               // Умножить r на n
  10: istore_1           // Сохранить результат в r
  11: iload_0            // Загрузить n
  12: iconst_1           // Загрузить 1
  13: isub               // Вычесть 1 из n
  14: istore_0           // Сохранить результат в n
  15: goto        2      // Перейти к началу цикла
  18: iload_1            // Загрузить r
  19: ireturn            // Вернуть r
~~~